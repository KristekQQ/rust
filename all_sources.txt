# Combined Cargo.toml
[package]
name = "webgpu_wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
# AktualizovÃ¡no na wgpu 25.0.2
wgpu = { version = "25.0.2", features = ["webgpu", "wgsl"] }
console_error_panic_hook = "0.1"
web-sys = { version = "0.3", features = [
    "HtmlCanvasElement",
    "Window",
    "Document",
    "console",
    "Performance",
    "EventTarget",
    "KeyboardEvent",
    "MouseEvent"
] }
glam    = { version = "0.30.3", default-features = false, features = ["libm","serde"] }
js-sys = "0.3"

\n# File: src/input/active_camera.rs
use crate::input::camera::{Camera, CameraController};
use crate::input::orbit_camera::OrbitCamera;
use glam::{Mat4, Vec3};

#[derive(Copy, Clone)]
pub enum CameraType {
    Free,
    Orbit,
}

pub struct ActiveCamera {
    free: Camera,
    orbit: OrbitCamera,
    active: CameraType,
}

impl ActiveCamera {
    pub fn new(aspect: f32) -> Self {
        Self {
            free: Camera::new(aspect),
            orbit: OrbitCamera::new(aspect),
            active: CameraType::Orbit,
        }
    }

    pub fn set_type(&mut self, ty: CameraType) {
        self.active = ty;
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.free.set_aspect(aspect);
        self.orbit.set_aspect(aspect);
    }

    fn active_mut(&mut self) -> &mut dyn CameraController {
        match self.active {
            CameraType::Free => &mut self.free,
            CameraType::Orbit => &mut self.orbit,
        }
    }

    fn active_ref(&self) -> &dyn CameraController {
        match self.active {
            CameraType::Free => &self.free,
            CameraType::Orbit => &self.orbit,
        }
    }
}

impl CameraController for ActiveCamera {
    fn key_down(&mut self, code: String) {
        self.active_mut().key_down(code);
    }

    fn key_up(&mut self, code: String) {
        self.active_mut().key_up(code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.active_mut().mouse_move(dx, dy);
    }

    fn update(&mut self, dt: f32) {
        self.active_mut().update(dt);
    }

    fn matrix(&self) -> Mat4 {
        self.active_ref().matrix()
    }

    fn position(&self) -> Vec3 {
        self.active_ref().position()
    }
}

\n# File: src/input/camera.rs
use glam::{Mat4, Vec3};
use std::collections::HashSet;

pub trait CameraController {
    fn key_down(&mut self, code: String);
    fn key_up(&mut self, code: String);
    fn mouse_move(&mut self, dx: f32, dy: f32);

    fn update(&mut self, dt: f32);
    fn matrix(&self) -> Mat4;
    fn position(&self) -> Vec3;
}

pub struct Camera {
    pub position: Vec3,
    yaw: f32,
    pitch: f32,
    pub speed: f32,
    pub sensitivity: f32,
    pressed: HashSet<String>,
    aspect: f32,
}

impl Camera {
    pub fn new(aspect: f32) -> Self {
        Self {
            position: Vec3::new(0.0, 0.0, 2.0),
            yaw: -std::f32::consts::FRAC_PI_2,
            pitch: 0.0,
            speed: 2.0,
            sensitivity: 0.002,
            pressed: HashSet::new(),
            aspect,
        }
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.aspect = aspect;
    }

    pub fn key_down(&mut self, code: String) {
        self.pressed.insert(code);
    }

    pub fn key_up(&mut self, code: String) {
        self.pressed.remove(&code);
    }

    pub fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.yaw -= dx * self.sensitivity;
        self.pitch = (self.pitch + dy * self.sensitivity).clamp(-1.54, 1.54);
    }

    pub fn update(&mut self, dt: f32) {
        let forward = self.forward();
        let right = Vec3::Y.cross(forward).normalize();
        if self.pressed.contains("KeyW") {
            self.position += forward * self.speed * dt;
        }
        if self.pressed.contains("KeyS") {
            self.position -= forward * self.speed * dt;
        }
        if self.pressed.contains("KeyA") {
            self.position -= right * self.speed * dt;
        }
        if self.pressed.contains("KeyD") {
            self.position += right * self.speed * dt;
        }
    }

    pub fn matrix(&self) -> Mat4 {
        let view = Mat4::look_at_lh(self.position, self.position + self.forward(), Vec3::Y);
        let proj = Mat4::perspective_lh(std::f32::consts::FRAC_PI_4, self.aspect, 0.1, 100.0);
        proj * view
    }

fn forward(&self) -> Vec3 {
        Vec3::new(
            self.yaw.cos() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.sin() * self.pitch.cos(),
        )
        .normalize()
    }
}

impl CameraController for Camera {
    fn key_down(&mut self, code: String) {
        Camera::key_down(self, code);
    }

    fn key_up(&mut self, code: String) {
        Camera::key_up(self, code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        Camera::mouse_move(self, dx, dy);
    }

    fn update(&mut self, dt: f32) {
        Camera::update(self, dt);
    }

    fn matrix(&self) -> Mat4 {
        Camera::matrix(self)
    }

    fn position(&self) -> Vec3 {
        self.position
    }
}

\n# File: src/input/keyboard.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::{closure::Closure, JsCast};
use web_sys::Window;

use crate::input::camera::CameraController;

pub fn attach<T>(window: &Window, cam: Rc<RefCell<T>>)
where
    T: CameraController + 'static,
{
    let cam_down = cam.clone();
    let key_down = Closure::wrap(Box::new(move |e: web_sys::KeyboardEvent| {
        cam_down.borrow_mut().key_down(e.code());
    }) as Box<dyn FnMut(_)>);
    window
        .add_event_listener_with_callback("keydown", key_down.as_ref().unchecked_ref())
        .unwrap();
    key_down.forget();

    let cam_up = cam.clone();
    let key_up = Closure::wrap(Box::new(move |e: web_sys::KeyboardEvent| {
        cam_up.borrow_mut().key_up(e.code());
    }) as Box<dyn FnMut(_)>);
    window
        .add_event_listener_with_callback("keyup", key_up.as_ref().unchecked_ref())
        .unwrap();
    key_up.forget();
}

\n# File: src/input/mod.rs
#![cfg(target_arch = "wasm32")]

pub mod camera;
pub mod orbit_camera;
pub mod active_camera;
pub mod keyboard;
pub mod mouse;

\n# File: src/input/mouse.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::{closure::Closure, JsCast};
use web_sys::Window;

use crate::input::camera::CameraController;

pub fn attach<T>(window: &Window, cam: Rc<RefCell<T>>)
where
    T: CameraController + 'static,
{
    let cam_mouse = cam.clone();
    let mouse_move = Closure::wrap(Box::new(move |e: web_sys::MouseEvent| {
        cam_mouse
            .borrow_mut()
            .mouse_move(e.movement_x() as f32, e.movement_y() as f32);
    }) as Box<dyn FnMut(_)>);
    window
        .add_event_listener_with_callback("mousemove", mouse_move.as_ref().unchecked_ref())
        .unwrap();
    mouse_move.forget();
}

\n# File: src/input/orbit_camera.rs
use glam::{Mat4, Vec3};
use std::collections::HashSet;

pub struct OrbitCamera {
    pub position: Vec3,
    target: Vec3,
    radius: f32,
    yaw: f32,
    pitch: f32,
    pub speed: f32,
    pub sensitivity: f32,
    pressed: HashSet<String>,
    aspect: f32,
}

impl OrbitCamera {
    pub fn new(aspect: f32) -> Self {
        let radius: f32 = 3.0;
        let yaw: f32 = 0.0;
        let pitch: f32 = 0.0;
        let target = Vec3::ZERO;
        let position = target
            + Vec3::new(radius * yaw.cos() * pitch.cos(), radius * pitch.sin(), radius * yaw.sin() * pitch.cos());
        Self {
            position,
            target,
            radius,
            yaw,
            pitch,
            speed: 2.0,
            sensitivity: 0.002,
            pressed: HashSet::new(),
            aspect,
        }
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.aspect = aspect;
    }

    pub fn key_down(&mut self, code: String) {
        self.pressed.insert(code);
    }

    pub fn key_up(&mut self, code: String) {
        self.pressed.remove(&code);
    }

    pub fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.yaw -= dx * self.sensitivity;
        self.pitch = (self.pitch + dy * self.sensitivity).clamp(-1.54, 1.54);
    }

    pub fn update(&mut self, dt: f32) {
        // Directions relative to the current camera orientation
        let forward = (self.target - self.position).normalize();
        let right = Vec3::Y.cross(forward).normalize();

        if self.pressed.contains("KeyW") {
            self.target += forward * self.speed * dt;
        }
        if self.pressed.contains("KeyS") {
            self.target -= forward * self.speed * dt;
        }
        if self.pressed.contains("KeyA") {
            self.target -= right * self.speed * dt;
        }
        if self.pressed.contains("KeyD") {
            self.target += right * self.speed * dt;
        }
        if self.pressed.contains("Equal") || self.pressed.contains("NumpadAdd") {
            self.radius = (self.radius - self.speed * dt).max(0.5);
        }
        if self.pressed.contains("Minus") || self.pressed.contains("NumpadSubtract") {
            self.radius += self.speed * dt;
        }
        // recalc position
        self.position = self.target
            + Vec3::new(
                self.radius * self.yaw.cos() * self.pitch.cos(),
                self.radius * self.pitch.sin(),
                self.radius * self.yaw.sin() * self.pitch.cos(),
            );
    }

pub fn matrix(&self) -> Mat4 {
        let view = Mat4::look_at_lh(self.position, self.target, Vec3::Y);
        let proj = Mat4::perspective_lh(std::f32::consts::FRAC_PI_4, self.aspect, 0.1, 100.0);
        proj * view
    }
}

use crate::input::camera::CameraController;

impl CameraController for OrbitCamera {
    fn key_down(&mut self, code: String) {
        OrbitCamera::key_down(self, code);
    }

    fn key_up(&mut self, code: String) {
        OrbitCamera::key_up(self, code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        OrbitCamera::mouse_move(self, dx, dy);
    }

    fn update(&mut self, dt: f32) {
        OrbitCamera::update(self, dt);
    }

    fn matrix(&self) -> Mat4 {
        OrbitCamera::matrix(self)
    }

    fn position(&self) -> Vec3 {
        self.position
    }
}


\n# File: src/lib.rs
#[cfg(target_arch = "wasm32")]
pub mod input;
#[cfg(target_arch = "wasm32")]
pub mod render;
#[cfg(target_arch = "wasm32")]
pub mod web;

\n# File: src/render/data.rs
#![cfg(target_arch = "wasm32")]

use wgpu::VertexBufferLayout;
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Vertex {
    pub position: [f32; 3],
    pub color: [f32; 3],
    pub normal: [f32; 3],
}

impl Vertex {
    pub fn layout<'a>() -> VertexBufferLayout<'a> {
        use std::mem;
        VertexBufferLayout {
            array_stride: mem::size_of::<Vertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: (mem::size_of::<[f32; 3]>() * 2) as wgpu::BufferAddress,
                    shader_location: 2,
                    format: wgpu::VertexFormat::Float32x3,
                },
            ],
        }
    }
}

pub const VERTICES: &[Vertex] = &[
    // front - red
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    // back - green
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    // left - blue
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    // right - yellow
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    // top - cyan
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    // bottom - magenta
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
];

pub const INDICES: &[u16] = &[
    0, 1, 2, 0, 2, 3, // front
    4, 5, 6, 4, 6, 7, // back
    8, 9, 10, 8, 10, 11, // left
    12, 13, 14, 12, 14, 15, // right
    16, 17, 18, 16, 18, 19, // top
    20, 21, 22, 20, 22, 23, // bottom
];

pub fn as_bytes<T: Copy>(data: &[T]) -> &[u8] {
    unsafe {
        std::slice::from_raw_parts(
            data.as_ptr() as *const u8,
            data.len() * std::mem::size_of::<T>(),
        )
    }
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct Light {
    pub position: [f32; 3],
    pub _pad_p: f32,
    pub color: [f32; 3],
    pub _pad_c: f32,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct SceneUniforms {
    pub mvp: [[f32; 4]; 4],
    pub model: [[f32; 4]; 4],
    pub camera_pos: [f32; 3],
    pub _pad0: f32,
    pub lights: [Light; 3],
}

pub fn grid_vertices(size: i32) -> Vec<Vertex> {
    let mut verts = Vec::new();
    let color = [0.3, 0.3, 0.3];
    let normal = [0.0, 1.0, 0.0];
    for i in -size..=size {
        let f = i as f32;
        verts.push(Vertex { position: [-size as f32, 0.0, f], color, normal });
        verts.push(Vertex { position: [size as f32, 0.0, f], color, normal });
        verts.push(Vertex { position: [f, 0.0, -size as f32], color, normal });
        verts.push(Vertex { position: [f, 0.0, size as f32], color, normal });
    }
    verts
}

pub fn light_rays(lights: &[Light]) -> Vec<Vertex> {
    let mut verts = Vec::new();
    let normal = [0.0_f32, 1.0, 0.0];
    let cross = 0.3_f32;
    for l in lights {
        let p = l.position;
        let color = l.color;
        // small cross marking the light position
        verts.push(Vertex { position: [p[0] - cross, p[1], p[2]], color, normal });
        verts.push(Vertex { position: [p[0] + cross, p[1], p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1] - cross, p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1] + cross, p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1], p[2] - cross], color, normal });
        verts.push(Vertex { position: [p[0], p[1], p[2] + cross], color, normal });
        // line from light to origin
        verts.push(Vertex { position: p, color, normal });
        verts.push(Vertex { position: [0.0, 0.0, 0.0], color, normal });
    }
    verts
}


\n# File: src/render/depth.rs
#![cfg(target_arch = "wasm32")]

use wgpu::{Device, Texture, TextureFormat, TextureView};

pub fn create(device: &Device, w: u32, h: u32, format: TextureFormat) -> (Texture, TextureView) {
    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth texture"),
        size: wgpu::Extent3d {
            width: w,
            height: h,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    (texture, view)
}

\n# File: src/render/mod.rs
#![cfg(target_arch = "wasm32")]

pub mod data;
pub mod depth;
pub mod pipeline;
pub mod state;
pub mod scene;

\n# File: src/render/pipeline.rs
#![cfg(target_arch = "wasm32")]

use crate::render::data::Vertex;
use wgpu::{BindGroupLayout, Device, RenderPipeline, TextureFormat};

pub fn build(device: &Device, format: TextureFormat, layout: &BindGroupLayout) -> RenderPipeline {
    let shader = device.create_shader_module(wgpu::include_wgsl!("../shader.wgsl"));
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline layout"),
        bind_group_layouts: &[layout],
        push_constant_ranges: &[],
    });
    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: Some("vs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            buffers: &[Vertex::layout()],
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: Some("fs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            targets: &[Some(wgpu::ColorTargetState {
                format,
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            cull_mode: Some(wgpu::Face::Front),
            front_face: wgpu::FrontFace::Ccw,
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: Default::default(),
            bias: Default::default(),
        }),
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
        cache: None,
    })
}

pub fn build_lines(device: &Device, format: TextureFormat, layout: &BindGroupLayout) -> RenderPipeline {
    let shader = device.create_shader_module(wgpu::include_wgsl!("../shader.wgsl"));
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("grid pipeline layout"),
        bind_group_layouts: &[layout],
        push_constant_ranges: &[],
    });
    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("grid pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: Some("vs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            buffers: &[Vertex::layout()],
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: Some("fs_color"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            targets: &[Some(wgpu::ColorTargetState {
                format,
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::LineList,
            cull_mode: None,
            front_face: wgpu::FrontFace::Ccw,
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: false,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: Default::default(),
            bias: Default::default(),
        }),
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
        cache: None,
    })
}


\n# File: src/render/scene.rs
#![cfg(target_arch = "wasm32")]

use glam::{Mat4, Vec3};
use wgpu::util::DeviceExt;

use super::data::{self, Vertex, SceneUniforms, Light as SceneLight};
use super::pipeline;

pub trait SceneObject {
    fn update(&mut self, dt: f32);
    fn draw<'r>(&'r self, pass: &mut wgpu::RenderPass<'r>, bind_group_layout: &wgpu::BindGroupLayout);
    fn set_camera(&mut self, _view_proj: Mat4, _cam_pos: Vec3, _lights: &[SceneLight; 3]) {}
    fn light_data(&self) -> Option<SceneLight> { None }
}

pub struct Mesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    pipeline: wgpu::RenderPipeline,
    model: Mat4,
    queue: wgpu::Queue,
}

impl Mesh {
    pub fn new(device: &wgpu::Device, queue: &wgpu::Queue, verts: &[Vertex], idx: &[u16], format: wgpu::TextureFormat, layout: &wgpu::BindGroupLayout, model: Mat4) -> Self {
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("mesh vertices"),
            contents: data::as_bytes(verts),
            usage: wgpu::BufferUsages::VERTEX,
        });
        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("mesh indices"),
            contents: data::as_bytes(idx),
            usage: wgpu::BufferUsages::INDEX,
        });
        let uniform = SceneUniforms {
            mvp: [[0.0;4];4],
            model: model.to_cols_array_2d(),
            camera_pos: [0.0;3],
            _pad0: 0.0,
            lights: [SceneLight { position: [0.0; 3], _pad_p: 0.0, color: [0.0; 3], _pad_c: 0.0 }; 3],
        };
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("mesh uniform"),
            contents: data::as_bytes(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
            label: Some("mesh bind group"),
        });
        let pipeline = pipeline::build(device, format, layout);
        Self {
            vertex_buffer,
            index_buffer,
            index_count: idx.len() as u32,
            uniform_buffer,
            bind_group,
            pipeline,
            model,
            queue: queue.clone(),
        }
    }

    pub fn cube(device: &wgpu::Device, queue: &wgpu::Queue, pos: [f32; 3], size: f32, format: wgpu::TextureFormat, layout: &wgpu::BindGroupLayout) -> Self {
        let mut verts = data::VERTICES.to_vec();
        for v in verts.iter_mut() {
            v.position[0] = v.position[0] * size + pos[0];
            v.position[1] = v.position[1] * size + pos[1];
            v.position[2] = v.position[2] * size + pos[2];
        }
        Self::new(device, queue, &verts, data::INDICES, format, layout, Mat4::IDENTITY)
    }
}

impl SceneObject for Mesh {
    fn update(&mut self, dt: f32) {
        // simple spin around Z for demo
        self.model = self.model * Mat4::from_rotation_z(dt);
    }

    fn draw<'r>(&'r self, pass: &mut wgpu::RenderPass<'r>, _layout: &wgpu::BindGroupLayout) {
        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, &self.bind_group, &[]);
        pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
        pass.draw_indexed(0..self.index_count, 0, 0..1);
    }

    fn set_camera(&mut self, view_proj: Mat4, cam_pos: Vec3, lights: &[SceneLight; 3]) {
        let mvp = view_proj * self.model;
        let uniform = SceneUniforms {
            mvp: mvp.to_cols_array_2d(),
            model: self.model.to_cols_array_2d(),
            camera_pos: cam_pos.into(),
            _pad0: 0.0,
            lights: *lights,
        };
        self.queue.write_buffer(&self.uniform_buffer, 0, data::as_bytes(&[uniform]));
    }
}

pub struct Light {
    position: [f32;3],
    color: [f32;3],
    vertex_buffer: wgpu::Buffer,
    vertex_count: u32,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    pipeline: wgpu::RenderPipeline,
    queue: wgpu::Queue,
}

impl Light {
    pub fn new(device: &wgpu::Device, queue: &wgpu::Queue, pos: [f32;3], color: [f32;3], format: wgpu::TextureFormat, layout: &wgpu::BindGroupLayout) -> Self {
        let l = SceneLight { position: pos, _pad_p: 0.0, color, _pad_c: 0.0 };
        let verts = data::light_rays(&[l]);
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("light verts"),
            contents: data::as_bytes(&verts),
            usage: wgpu::BufferUsages::VERTEX,
        });
        let uniform = SceneUniforms {
            mvp: [[0.0;4];4],
            model: Mat4::IDENTITY.to_cols_array_2d(),
            camera_pos: [0.0;3],
            _pad0: 0.0,
            lights: [SceneLight { position: [0.0;3], _pad_p: 0.0, color: [0.0;3], _pad_c: 0.0 }; 3],
        };
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("light uniform"),
            contents: data::as_bytes(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout,
            entries: &[wgpu::BindGroupEntry { binding: 0, resource: uniform_buffer.as_entire_binding() }],
            label: Some("light bind group"),
        });
        let pipeline = pipeline::build_lines(device, format, layout);
        Self {
            position: pos,
            color,
            vertex_buffer,
            vertex_count: verts.len() as u32,
            uniform_buffer,
            bind_group,
            pipeline,
            queue: queue.clone(),
        }
    }
}

impl SceneObject for Light {
    fn update(&mut self, _dt: f32) {}

    fn draw<'r>(&'r self, pass: &mut wgpu::RenderPass<'r>, _layout: &wgpu::BindGroupLayout) {
        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, &self.bind_group, &[]);
        pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        pass.draw(0..self.vertex_count, 0..1);
    }

    fn set_camera(&mut self, view_proj: Mat4, cam_pos: Vec3, lights: &[SceneLight; 3]) {
        let uniform = SceneUniforms {
            mvp: view_proj.to_cols_array_2d(),
            model: Mat4::IDENTITY.to_cols_array_2d(),
            camera_pos: cam_pos.into(),
            _pad0: 0.0,
            lights: *lights,
        };
        self.queue.write_buffer(&self.uniform_buffer, 0, data::as_bytes(&[uniform]));
    }

    fn light_data(&self) -> Option<SceneLight> {
        Some(SceneLight { position: self.position, _pad_p: 0.0, color: self.color, _pad_c: 0.0 })
    }
}

pub struct Grid {
    vertex_buffer: wgpu::Buffer,
    vertex_count: u32,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    pipeline: wgpu::RenderPipeline,
    queue: wgpu::Queue,
}

impl Grid {
    pub fn new(device: &wgpu::Device, queue: &wgpu::Queue, size: i32, format: wgpu::TextureFormat, layout: &wgpu::BindGroupLayout) -> Self {
        let verts = data::grid_vertices(size);
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("grid verts"),
            contents: data::as_bytes(&verts),
            usage: wgpu::BufferUsages::VERTEX,
        });
        let uniform = SceneUniforms {
            mvp: [[0.0; 4]; 4],
            model: Mat4::IDENTITY.to_cols_array_2d(),
            camera_pos: [0.0; 3],
            _pad0: 0.0,
            lights: [SceneLight { position: [0.0; 3], _pad_p: 0.0, color: [0.0; 3], _pad_c: 0.0 }; 3],
        };
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("grid uniform"),
            contents: data::as_bytes(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout,
            entries: &[wgpu::BindGroupEntry { binding: 0, resource: uniform_buffer.as_entire_binding() }],
            label: Some("grid bind group"),
        });
        let pipeline = pipeline::build_lines(device, format, layout);
        Self { vertex_buffer, vertex_count: verts.len() as u32, uniform_buffer, bind_group, pipeline, queue: queue.clone() }
    }
}

impl SceneObject for Grid {
    fn update(&mut self, _dt: f32) {}

    fn draw<'r>(&'r self, pass: &mut wgpu::RenderPass<'r>, _layout: &wgpu::BindGroupLayout) {
        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, &self.bind_group, &[]);
        pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        pass.draw(0..self.vertex_count, 0..1);
    }

    fn set_camera(&mut self, view_proj: Mat4, cam_pos: Vec3, lights: &[SceneLight; 3]) {
        let uniform = SceneUniforms {
            mvp: view_proj.to_cols_array_2d(),
            model: Mat4::IDENTITY.to_cols_array_2d(),
            camera_pos: cam_pos.into(),
            _pad0: 0.0,
            lights: *lights,
        };
        self.queue.write_buffer(&self.uniform_buffer, 0, data::as_bytes(&[uniform]));
    }
}

pub struct SceneManager {
    objects: Vec<Box<dyn SceneObject>>,
    bind_group_layout: wgpu::BindGroupLayout,
    format: wgpu::TextureFormat,
    device: wgpu::Device,
    queue: wgpu::Queue,
}

impl SceneManager {
    pub fn new(device: wgpu::Device, queue: wgpu::Queue, format: wgpu::TextureFormat) -> Self {
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("scene bind layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Uniform, has_dynamic_offset: false, min_binding_size: None },
                count: None,
            }],
        });
        Self { objects: Vec::new(), bind_group_layout, format, device, queue }
    }

    pub fn bind_group_layout(&self) -> &wgpu::BindGroupLayout { &self.bind_group_layout }
    pub fn device(&self) -> &wgpu::Device { &self.device }
    pub fn queue(&self) -> &wgpu::Queue { &self.queue }
    pub fn format(&self) -> wgpu::TextureFormat { self.format }

    pub fn add_mesh(&mut self, verts: &[Vertex], idx: &[u16], model: Mat4) -> usize {
        let mesh = Mesh::new(&self.device, &self.queue, verts, idx, self.format, &self.bind_group_layout, model);
        let id = self.objects.len();
        self.objects.push(Box::new(mesh));
        id
    }

    pub fn add_light(&mut self, pos: [f32;3], color: [f32;3]) -> usize {
        let light = Light::new(&self.device, &self.queue, pos, color, self.format, &self.bind_group_layout);
        let id = self.objects.len();
        self.objects.push(Box::new(light));
        id
    }

    pub fn add_grid(&mut self, size: i32) -> usize {
        let grid = Grid::new(&self.device, &self.queue, size, self.format, &self.bind_group_layout);
        let id = self.objects.len();
        self.objects.push(Box::new(grid));
        id
    }

    pub fn remove(&mut self, id: usize) {
        if id < self.objects.len() {
            self.objects.remove(id);
        }
    }

    fn lights_array(&self) -> [SceneLight; 3] {
        // Pokud nenÃ­ pÅidÃ¡no Å¾Ã¡dnÃ© svÄtlo, chceme mÃ­t prÃ¡zdnÃ© sloty
        let default = SceneLight { position: [0.0; 3], _pad_p: 0.0, color: [0.0; 3], _pad_c: 0.0 };
        let mut arr = [default; 3];
        let mut i = 0;
        for o in self.objects.iter() {
            if let Some(l) = o.light_data() {
                if i < 3 { arr[i] = l; i += 1; }
            }
        }
        arr
    }

    pub fn update(&mut self, dt: f32) {
        for o in self.objects.iter_mut() {
            o.update(dt);
        }
    }

    pub fn set_camera(&mut self, view_proj: Mat4, cam_pos: Vec3) {
        let lights = self.lights_array();
        for o in self.objects.iter_mut() {
            o.set_camera(view_proj, cam_pos, &lights);
        }
    }

    pub fn draw<'r>(&'r self, pass: &mut wgpu::RenderPass<'r>) {
        for o in self.objects.iter() {
            o.draw(pass, &self.bind_group_layout);
        }
    }
}


\n# File: src/render/state.rs
#![cfg(target_arch = "wasm32")]

use wasm_bindgen::JsValue;
use web_sys::HtmlCanvasElement;

use super::{depth, scene::SceneManager};

pub struct State {
    surface: wgpu::Surface<'static>,
    device: wgpu::Device,
    queue: wgpu::Queue,
    config: wgpu::SurfaceConfiguration,
    depth_texture: wgpu::Texture,
    depth_view: wgpu::TextureView,
    depth_format: wgpu::TextureFormat,
    bind_group_layout: wgpu::BindGroupLayout,
    pub aspect: f32,
}

impl State {
    pub async fn new(canvas: &HtmlCanvasElement) -> Result<Self, JsValue> {
        let instance = wgpu::Instance::default();
        let surface = instance
            .create_surface(wgpu::SurfaceTarget::Canvas(canvas.clone()))
            .map_err(|e| JsValue::from_str(&format!("{e:?}")))?;
        let surface = unsafe { std::mem::transmute::<wgpu::Surface<'_>, wgpu::Surface<'static>>(surface) };
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::HighPerformance,
                compatible_surface: Some(&surface),
                force_fallback_adapter: false,
            })
            .await
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: None,
                    required_features: wgpu::Features::empty(),
                    required_limits: adapter.limits(),
                    memory_hints: wgpu::MemoryHints::default(),
                    trace: wgpu::Trace::default(),
                },
            )
            .await
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        let caps = surface.get_capabilities(&adapter);
        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: caps.formats[0],
            width: canvas.width(),
            height: canvas.height(),
            present_mode: caps.present_modes[0],
            desired_maximum_frame_latency: 2,
            alpha_mode: caps.alpha_modes[0],
            view_formats: vec![],
        };
        surface.configure(&device, &config);
        let aspect = config.width as f32 / config.height as f32;

        let depth_format = wgpu::TextureFormat::Depth32Float;
        let (depth_texture, depth_view) = depth::create(&device, config.width, config.height, depth_format);
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("bind group layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        Ok(Self {
            surface,
            device,
            queue,
            config,
            depth_texture,
            depth_view,
            depth_format,
            bind_group_layout,
            aspect,
        })
    }

    pub fn bind_group_layout(&self) -> &wgpu::BindGroupLayout {
        &self.bind_group_layout
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        if width == 0 || height == 0 {
            return;
        }
        self.config.width = width;
        self.config.height = height;
        self.aspect = width as f32 / height as f32;
        self.surface.configure(&self.device, &self.config);
        let (depth_texture, depth_view) = depth::create(&self.device, width, height, self.depth_format);
        self.depth_texture = depth_texture;
        self.depth_view = depth_view;
    }

    pub fn render(&mut self, scene: &SceneManager) -> Result<(), wgpu::SurfaceError> {
        let frame = self.surface.get_current_texture()?;
        let view = frame.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("encoder") });
        {
            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("render"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color { r: 0.1, g: 0.1, b: 0.3, a: 1.0 }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                    view: &self.depth_view,
                    depth_ops: Some(wgpu::Operations { load: wgpu::LoadOp::Clear(1.0), store: wgpu::StoreOp::Store }),
                    stencil_ops: None,
                }),
                occlusion_query_set: None,
                timestamp_writes: None,
            });
            scene.draw(&mut rp);
        }
        self.queue.submit(Some(encoder.finish()));
        frame.present();
        Ok(())
    }

    pub fn device(&self) -> &wgpu::Device { &self.device }
    pub fn queue(&self) -> &wgpu::Queue { &self.queue }
    pub fn format(&self) -> wgpu::TextureFormat { self.config.format }
}

\n# File: src/shader.wgsl
struct Light {
    position: vec3<f32>,
    _pad_p: f32,
    color: vec3<f32>,
    _pad_c: f32,
};

struct SceneUniforms {
    mvp: mat4x4<f32>,
    model: mat4x4<f32>,
    camera_pos: vec3<f32>,
    _pad0: f32,
    lights: array<Light, 3>,
};

@group(0) @binding(0) var<uniform> scene: SceneUniforms;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) color: vec3<f32>,
    @location(2) normal: vec3<f32>,
};

struct VertexOutput {
    @builtin(position) pos: vec4<f32>,
    @location(0) color: vec3<f32>,
    @location(1) world_pos: vec3<f32>,
    @location(2) world_normal: vec3<f32>,
};

@vertex
fn vs_main(input: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.pos = scene.mvp * vec4<f32>(input.position, 1.0);
    out.color = input.color;
    out.world_pos = (scene.model * vec4<f32>(input.position, 1.0)).xyz;
    // Transform the normal by the model matrix without applying translation
    // (w = 0). This keeps lighting separate from camera rotation.
    out.world_normal = normalize((scene.model * vec4<f32>(input.normal, 0.0)).xyz);
    return out;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let normal = normalize(input.world_normal);
    let view_dir = normalize(scene.camera_pos - input.world_pos);
    var result = input.color * 0.1; // ambient

    // light 0
    let l0_dir = normalize(scene.lights[0].position - input.world_pos);
    let diff0 = max(dot(normal, l0_dir), 0.0);
    let spec0 = pow(max(dot(normal, normalize(l0_dir + view_dir)), 0.0), 32.0);
    result += (diff0 * input.color + spec0) * scene.lights[0].color;

    // light 1
    let l1_dir = normalize(scene.lights[1].position - input.world_pos);
    let diff1 = max(dot(normal, l1_dir), 0.0);
    let spec1 = pow(max(dot(normal, normalize(l1_dir + view_dir)), 0.0), 32.0);
    result += (diff1 * input.color + spec1) * scene.lights[1].color;

    // light 2
    let l2_dir = normalize(scene.lights[2].position - input.world_pos);
    let diff2 = max(dot(normal, l2_dir), 0.0);
    let spec2 = pow(max(dot(normal, normalize(l2_dir + view_dir)), 0.0), 32.0);
    result += (diff2 * input.color + spec2) * scene.lights[2].color;

    return vec4<f32>(result, 1.0);
}

@fragment
fn fs_color(input: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(input.color, 1.0);
}

\n# File: src/web.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::prelude::*;
use wasm_bindgen::{closure::Closure, JsCast};

use glam::Mat4;

use crate::input::active_camera::{ActiveCamera, CameraType};
use crate::input::camera::CameraController;
use crate::input::{keyboard, mouse};
use crate::render::scene::SceneManager;
use crate::render::data;
use crate::render::state::State;

thread_local! {
    static STATE: RefCell<Option<Rc<RefCell<State>>>> = RefCell::new(None);
    static CAMERA: RefCell<Option<Rc<RefCell<ActiveCamera>>>> = RefCell::new(None);
    static SCENE_MANAGER: RefCell<Option<SceneManager>> = RefCell::new(None);
    static GRID_ID: RefCell<Option<usize>> = RefCell::new(None);
}

#[wasm_bindgen]
pub fn set_grid_visible(show: bool) {
    SCENE_MANAGER.with(|sc| {
        if let Some(mgr) = &mut *sc.borrow_mut() {
            GRID_ID.with(|id_cell| {
                if show {
                    if id_cell.borrow().is_none() {
                        let id = mgr.add_grid(10);
                        *id_cell.borrow_mut() = Some(id);
                    }
                } else if let Some(id) = id_cell.borrow_mut().take() {
                    mgr.remove(id);
                }
            });
        }
    });
}

#[wasm_bindgen]
pub fn set_camera_mode(mode: &str) {
    CAMERA.with(|c| {
        if let Some(cam) = &*c.borrow() {
            let mut cam = cam.borrow_mut();
            match mode {
                "free" => cam.set_type(CameraType::Free),
                "orbit" => cam.set_type(CameraType::Orbit),
                _ => {}
            }
        }
    });
}

#[wasm_bindgen]
pub fn resize(width: u32, height: u32) {
    STATE.with(|s| {
        if let Some(st) = &*s.borrow() {
            st.borrow_mut().resize(width, height);
        }
    });
    CAMERA.with(|c| {
        if let Some(cam) = &*c.borrow() {
            cam.borrow_mut().set_aspect(width as f32 / height as f32);
        }
    });
}

#[wasm_bindgen]
pub fn add_cube(position: js_sys::Array, size: f32) -> usize {
    if position.length() != 3 { return 0; }
    let pos = [
        position.get(0).as_f64().unwrap_or(0.0) as f32,
        position.get(1).as_f64().unwrap_or(0.0) as f32,
        position.get(2).as_f64().unwrap_or(0.0) as f32,
    ];
    SCENE_MANAGER.with(|s| {
        if let Some(scene) = &mut *s.borrow_mut() {
            let mut verts = crate::render::data::VERTICES.to_vec();
            for v in verts.iter_mut() {
                v.position[0] = v.position[0] * size + pos[0];
                v.position[1] = v.position[1] * size + pos[1];
                v.position[2] = v.position[2] * size + pos[2];
            }
            return scene.add_mesh(&verts, crate::render::data::INDICES, Mat4::IDENTITY);
        }
        0
    })
}

#[wasm_bindgen]
pub fn add_light(position: js_sys::Array, color: js_sys::Array) -> usize {
    if position.length() != 3 || color.length() != 3 { return 0; }
    let pos = [
        position.get(0).as_f64().unwrap_or(0.0) as f32,
        position.get(1).as_f64().unwrap_or(0.0) as f32,
        position.get(2).as_f64().unwrap_or(0.0) as f32,
    ];
    let col = [
        color.get(0).as_f64().unwrap_or(1.0) as f32,
        color.get(1).as_f64().unwrap_or(1.0) as f32,
        color.get(2).as_f64().unwrap_or(1.0) as f32,
    ];
    SCENE_MANAGER.with(|s| {
        if let Some(scene) = &mut *s.borrow_mut() {
            return scene.add_light(pos, col);
        }
        0
    })
}

#[wasm_bindgen(start)]
pub async fn start() -> Result<(), JsValue> {
    console_error_panic_hook::set_once();
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let canvas = document
        .get_element_by_id("gpu-canvas")
        .unwrap()
        .dyn_into::<web_sys::HtmlCanvasElement>()?;

    let state = Rc::new(RefCell::new(State::new(&canvas).await?));
    let mut manager = SceneManager::new(
        state.borrow().device().clone(),
        state.borrow().queue().clone(),
        state.borrow().format(),
    );
    manager.add_grid(10);
    manager.add_mesh(data::VERTICES, data::INDICES, Mat4::IDENTITY);
    STATE.with(|s| *s.borrow_mut() = Some(state.clone()));
    SCENE_MANAGER.with(|sc| *sc.borrow_mut() = Some(manager));
    let performance = window.performance().unwrap();
    let aspect = state.borrow().aspect;
    let camera = Rc::new(RefCell::new(ActiveCamera::new(aspect)));
    CAMERA.with(|c| *c.borrow_mut() = Some(camera.clone()));

    keyboard::attach(&window, camera.clone());
    mouse::attach(&window, camera.clone());

    let start_time = performance.now();
    let prev_time = Rc::new(RefCell::new(start_time));
    let f: Rc<RefCell<Option<Closure<dyn FnMut()>>>> = Rc::new(RefCell::new(None));
    let g = f.clone();
    let window_c = window.clone();
    let perf_c = performance.clone();
    let camera_c = camera.clone();
    let prev_time_c = prev_time.clone();

    *g.borrow_mut() = Some(Closure::wrap(Box::new(move || {
        let now = perf_c.now();
        let dt = (now - *prev_time_c.borrow()) as f32 / 1000.0;
        *prev_time_c.borrow_mut() = now;
        let mut cam = camera_c.borrow_mut();
        cam.update(dt);
        let cam_pos = cam.position();
        let cam_matrix = cam.matrix();
        SCENE_MANAGER.with(|sc| {
            if let Some(mgr) = &mut *sc.borrow_mut() {
                mgr.update(dt);
                mgr.set_camera(cam_matrix, cam_pos);
                STATE.with(|st| {
                    if let Some(state) = &*st.borrow() {
                        if state.borrow_mut().render(mgr).is_err() {
                            return;
                        }
                    }
                });
            }
        });
        window_c
            .request_animation_frame(f.borrow().as_ref().unwrap().as_ref().unchecked_ref())
            .unwrap();
    }) as Box<dyn FnMut()>));

    window.request_animation_frame(g.borrow().as_ref().unwrap().as_ref().unchecked_ref())?;
    Ok(())
}

