# Combined Cargo.toml
[package]
name = "webgpu_wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
# AktualizovÃ¡no na wgpu 25.0.2
wgpu = { version = "25.0.2", features = ["webgpu", "wgsl"] }
console_error_panic_hook = "0.1"
web-sys = { version = "0.3", features = [
    "HtmlCanvasElement",
    "Window",
    "Document",
    "console",
    "Performance",
    "EventTarget",
    "KeyboardEvent",
    "MouseEvent",
    "PointerEvent"
] }
glam    = { version = "0.30.3", default-features = false, features = ["libm","serde"] }
js-sys = "0.3"

\n# File: src/input/active_camera.rs
use crate::input::camera::{Camera, CameraController};
use crate::input::orbit_camera::OrbitCamera;
use glam::{Mat4, Vec3};

#[derive(Copy, Clone)]
pub enum CameraType {
    Free,
    Orbit,
}

pub struct ActiveCamera {
    free: Camera,
    orbit: OrbitCamera,
    active: CameraType,
}

impl ActiveCamera {
    pub fn new(aspect: f32) -> Self {
        Self {
            free: Camera::new(aspect),
            orbit: OrbitCamera::new(aspect),
            active: CameraType::Orbit,
        }
    }

    pub fn set_type(&mut self, ty: CameraType) {
        self.active = ty;
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.free.set_aspect(aspect);
        self.orbit.set_aspect(aspect);
    }

    fn active_mut(&mut self) -> &mut dyn CameraController {
        match self.active {
            CameraType::Free => &mut self.free,
            CameraType::Orbit => &mut self.orbit,
        }
    }

    fn active_ref(&self) -> &dyn CameraController {
        match self.active {
            CameraType::Free => &self.free,
            CameraType::Orbit => &self.orbit,
        }
    }
}

impl CameraController for ActiveCamera {
    fn key_down(&mut self, code: String) {
        self.active_mut().key_down(code);
    }

    fn key_up(&mut self, code: String) {
        self.active_mut().key_up(code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.active_mut().mouse_move(dx, dy);
    }

    fn update(&mut self, dt: f32) {
        self.active_mut().update(dt);
    }

    fn matrix(&self) -> Mat4 {
        self.active_ref().matrix()
    }

    fn position(&self) -> Vec3 {
        self.active_ref().position()
    }
}

\n# File: src/input/camera.rs
use glam::{Mat4, Vec3};
use std::collections::HashSet;

pub trait CameraController {
    fn key_down(&mut self, code: String);
    fn key_up(&mut self, code: String);
    fn mouse_move(&mut self, dx: f32, dy: f32);

    fn update(&mut self, dt: f32);
    fn matrix(&self) -> Mat4;
    fn position(&self) -> Vec3;
}

pub struct Camera {
    pub position: Vec3,
    yaw: f32,
    pitch: f32,
    pub speed: f32,
    pub sensitivity: f32,
    pressed: HashSet<String>,
    aspect: f32,
}

impl Camera {
    pub fn new(aspect: f32) -> Self {
        Self {
            position: Vec3::new(0.0, 0.0, 2.0),
            yaw: -std::f32::consts::FRAC_PI_2,
            pitch: 0.0,
            speed: 2.0,
            sensitivity: 0.002,
            pressed: HashSet::new(),
            aspect,
        }
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.aspect = aspect;
    }

    pub fn key_down(&mut self, code: String) {
        self.pressed.insert(code);
    }

    pub fn key_up(&mut self, code: String) {
        self.pressed.remove(&code);
    }

    pub fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.yaw -= dx * self.sensitivity;
        self.pitch = (self.pitch + dy * self.sensitivity).clamp(-1.54, 1.54);
    }

    pub fn update(&mut self, dt: f32) {
        let forward = self.forward();
        let right = Vec3::Y.cross(forward).normalize();
        if self.pressed.contains("KeyW") {
            self.position += forward * self.speed * dt;
        }
        if self.pressed.contains("KeyS") {
            self.position -= forward * self.speed * dt;
        }
        if self.pressed.contains("KeyA") {
            self.position -= right * self.speed * dt;
        }
        if self.pressed.contains("KeyD") {
            self.position += right * self.speed * dt;
        }
    }

    pub fn matrix(&self) -> Mat4 {
        let view = Mat4::look_at_lh(self.position, self.position + self.forward(), Vec3::Y);
        let proj = Mat4::perspective_lh(std::f32::consts::FRAC_PI_4, self.aspect, 0.1, 100.0);
        proj * view
    }

fn forward(&self) -> Vec3 {
        Vec3::new(
            self.yaw.cos() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.sin() * self.pitch.cos(),
        )
        .normalize()
    }
}

impl CameraController for Camera {
    fn key_down(&mut self, code: String) {
        Camera::key_down(self, code);
    }

    fn key_up(&mut self, code: String) {
        Camera::key_up(self, code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        Camera::mouse_move(self, dx, dy);
    }

    fn update(&mut self, dt: f32) {
        Camera::update(self, dt);
    }

    fn matrix(&self) -> Mat4 {
        Camera::matrix(self)
    }

    fn position(&self) -> Vec3 {
        self.position
    }
}

\n# File: src/input/keyboard.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::{closure::Closure, JsCast};
use web_sys::Window;

use crate::input::camera::CameraController;

pub fn attach<T>(window: &Window, cam: Rc<RefCell<T>>)
where
    T: CameraController + 'static,
{
    let cam_down = cam.clone();
    let key_down = Closure::wrap(Box::new(move |e: web_sys::KeyboardEvent| {
        cam_down.borrow_mut().key_down(e.code());
    }) as Box<dyn FnMut(_)>);
    window
        .add_event_listener_with_callback("keydown", key_down.as_ref().unchecked_ref())
        .unwrap();
    key_down.forget();

    let cam_up = cam.clone();
    let key_up = Closure::wrap(Box::new(move |e: web_sys::KeyboardEvent| {
        cam_up.borrow_mut().key_up(e.code());
    }) as Box<dyn FnMut(_)>);
    window
        .add_event_listener_with_callback("keyup", key_up.as_ref().unchecked_ref())
        .unwrap();
    key_up.forget();
}

\n# File: src/input/mod.rs
#![cfg(target_arch = "wasm32")]

pub mod camera;
pub mod orbit_camera;
pub mod active_camera;
pub mod keyboard;
pub mod mouse;

\n# File: src/input/mouse.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::{closure::Closure, JsCast};
use web_sys::{Window, HtmlCanvasElement, PointerEvent};

use crate::input::camera::CameraController;

pub fn attach<T>(window: &Window, canvas: &HtmlCanvasElement, cam: Rc<RefCell<T>>)
where
    T: CameraController + 'static,
{
    let dragging = Rc::new(RefCell::new(false));

    // Start dragging only when the left button is pressed on the canvas
    {
        let dragging = dragging.clone();
        let canvas_clone = canvas.clone();
        let on_down = Closure::wrap(Box::new(move |e: PointerEvent| {
            if e.buttons() & 1 == 1 {
                if let Some(target) = e.target() {
                    if target == canvas_clone
                        .clone()
                        .dyn_into::<web_sys::EventTarget>()
                        .unwrap()
                    {
                        *dragging.borrow_mut() = true;
                    }
                }
            }
        }) as Box<dyn FnMut(_)>);
        canvas
            .add_event_listener_with_callback("pointerdown", on_down.as_ref().unchecked_ref())
            .unwrap();
        on_down.forget();
    }

    // Stop dragging on mouseup anywhere in the window
    {
        let dragging = dragging.clone();
        let on_up = Closure::wrap(Box::new(move |_e: PointerEvent| {
            *dragging.borrow_mut() = false;
        }) as Box<dyn FnMut(_)>);
        window
            .add_event_listener_with_callback("pointerup", on_up.as_ref().unchecked_ref())
            .unwrap();
        on_up.forget();
    }

    // Apply mouse movement only while dragging
    {
        let dragging = dragging.clone();
        let cam_mouse = cam.clone();
        let mouse_move = Closure::wrap(Box::new(move |e: PointerEvent| {
            if *dragging.borrow() && e.buttons() & 1 == 1 {
                cam_mouse
                    .borrow_mut()
                    .mouse_move(e.movement_x() as f32, e.movement_y() as f32);
            }
        }) as Box<dyn FnMut(_)>);
        window
            .add_event_listener_with_callback("pointermove", mouse_move.as_ref().unchecked_ref())
            .unwrap();
        mouse_move.forget();
    }
}

\n# File: src/input/orbit_camera.rs
use glam::{Mat4, Vec3};
use std::collections::HashSet;

pub struct OrbitCamera {
    pub position: Vec3,
    target: Vec3,
    radius: f32,
    yaw: f32,
    pitch: f32,
    pub speed: f32,
    pub sensitivity: f32,
    pressed: HashSet<String>,
    aspect: f32,
}

impl OrbitCamera {
    pub fn new(aspect: f32) -> Self {
        let radius: f32 = 3.0;
        let yaw: f32 = 0.0;
        let pitch: f32 = 0.0;
        let target = Vec3::ZERO;
        let position = target
            + Vec3::new(radius * yaw.cos() * pitch.cos(), radius * pitch.sin(), radius * yaw.sin() * pitch.cos());
        Self {
            position,
            target,
            radius,
            yaw,
            pitch,
            speed: 2.0,
            sensitivity: 0.002,
            pressed: HashSet::new(),
            aspect,
        }
    }

    pub fn set_aspect(&mut self, aspect: f32) {
        self.aspect = aspect;
    }

    pub fn key_down(&mut self, code: String) {
        self.pressed.insert(code);
    }

    pub fn key_up(&mut self, code: String) {
        self.pressed.remove(&code);
    }

    pub fn mouse_move(&mut self, dx: f32, dy: f32) {
        self.yaw -= dx * self.sensitivity;
        self.pitch = (self.pitch + dy * self.sensitivity).clamp(-1.54, 1.54);
    }

    pub fn update(&mut self, dt: f32) {
        // Directions relative to the current camera orientation
        let forward = (self.target - self.position).normalize();
        let right = Vec3::Y.cross(forward).normalize();

        if self.pressed.contains("KeyW") {
            self.target += forward * self.speed * dt;
        }
        if self.pressed.contains("KeyS") {
            self.target -= forward * self.speed * dt;
        }
        if self.pressed.contains("KeyA") {
            self.target -= right * self.speed * dt;
        }
        if self.pressed.contains("KeyD") {
            self.target += right * self.speed * dt;
        }
        if self.pressed.contains("Equal") || self.pressed.contains("NumpadAdd") {
            self.radius = (self.radius - self.speed * dt).max(0.5);
        }
        if self.pressed.contains("Minus") || self.pressed.contains("NumpadSubtract") {
            self.radius += self.speed * dt;
        }
        // recalc position
        self.position = self.target
            + Vec3::new(
                self.radius * self.yaw.cos() * self.pitch.cos(),
                self.radius * self.pitch.sin(),
                self.radius * self.yaw.sin() * self.pitch.cos(),
            );
    }

pub fn matrix(&self) -> Mat4 {
        let view = Mat4::look_at_lh(self.position, self.target, Vec3::Y);
        let proj = Mat4::perspective_lh(std::f32::consts::FRAC_PI_4, self.aspect, 0.1, 100.0);
        proj * view
    }
}

use crate::input::camera::CameraController;

impl CameraController for OrbitCamera {
    fn key_down(&mut self, code: String) {
        OrbitCamera::key_down(self, code);
    }

    fn key_up(&mut self, code: String) {
        OrbitCamera::key_up(self, code);
    }

    fn mouse_move(&mut self, dx: f32, dy: f32) {
        OrbitCamera::mouse_move(self, dx, dy);
    }

    fn update(&mut self, dt: f32) {
        OrbitCamera::update(self, dt);
    }

    fn matrix(&self) -> Mat4 {
        OrbitCamera::matrix(self)
    }

    fn position(&self) -> Vec3 {
        self.position
    }
}


\n# File: src/lib.rs
#[cfg(target_arch = "wasm32")]
pub mod input;
#[cfg(target_arch = "wasm32")]
pub mod render;
#[cfg(target_arch = "wasm32")]
pub mod scene;
#[cfg(target_arch = "wasm32")]
pub mod web;

\n# File: src/render/data.rs
#![cfg(target_arch = "wasm32")]

use wgpu::VertexBufferLayout;
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Vertex {
    pub position: [f32; 3],
    pub color: [f32; 3],
    pub normal: [f32; 3],
}

impl Vertex {
    pub fn layout<'a>() -> VertexBufferLayout<'a> {
        use std::mem;
        VertexBufferLayout {
            array_stride: mem::size_of::<Vertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: (mem::size_of::<[f32; 3]>() * 2) as wgpu::BufferAddress,
                    shader_location: 2,
                    format: wgpu::VertexFormat::Float32x3,
                },
            ],
        }
    }
}

pub const VERTICES: &[Vertex] = &[
    // front - red
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [1.0, 0.0, 0.0],
        normal: [0.0, 0.0, 1.0],
    },
    // back - green
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [0.0, 1.0, 0.0],
        normal: [0.0, 0.0, -1.0],
    },
    // left - blue
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 0.0, 1.0],
        normal: [-1.0, 0.0, 0.0],
    },
    // right - yellow
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [1.0, 1.0, 0.0],
        normal: [1.0, 0.0, 0.0],
    },
    // top - cyan
    Vertex {
        position: [-0.5, 0.5, 0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, 0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [0.5, 0.5, -0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    Vertex {
        position: [-0.5, 0.5, -0.5],
        color: [0.0, 1.0, 1.0],
        normal: [0.0, 1.0, 0.0],
    },
    // bottom - magenta
    Vertex {
        position: [-0.5, -0.5, -0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, -0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [0.5, -0.5, 0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
    Vertex {
        position: [-0.5, -0.5, 0.5],
        color: [1.0, 0.0, 1.0],
        normal: [0.0, -1.0, 0.0],
    },
];

pub const INDICES: &[u16] = &[
    0, 1, 2, 0, 2, 3, // front
    4, 5, 6, 4, 6, 7, // back
    8, 9, 10, 8, 10, 11, // left
    12, 13, 14, 12, 14, 15, // right
    16, 17, 18, 16, 18, 19, // top
    20, 21, 22, 20, 22, 23, // bottom
];

pub fn as_bytes<T: Copy>(data: &[T]) -> &[u8] {
    unsafe {
        std::slice::from_raw_parts(
            data.as_ptr() as *const u8,
            data.len() * std::mem::size_of::<T>(),
        )
    }
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct Light {
    pub position: [f32; 3],
    pub _pad_p: f32,
    pub color: [f32; 3],
    pub _pad_c: f32,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct SceneUniforms {
    pub mvp: [[f32; 4]; 4],
    pub model: [[f32; 4]; 4],
    pub camera_pos: [f32; 3],
    pub _pad0: f32,
    pub lights: [Light; 2],
}

pub fn grid_vertices(size: i32) -> Vec<Vertex> {
    let mut verts = Vec::new();
    let color = [0.3, 0.3, 0.3];
    let normal = [0.0, 1.0, 0.0];
    for i in -size..=size {
        let f = i as f32;
        verts.push(Vertex { position: [-size as f32, 0.0, f], color, normal });
        verts.push(Vertex { position: [size as f32, 0.0, f], color, normal });
        verts.push(Vertex { position: [f, 0.0, -size as f32], color, normal });
        verts.push(Vertex { position: [f, 0.0, size as f32], color, normal });
    }
    verts
}

pub fn light_rays(lights: &[Light]) -> Vec<Vertex> {
    let mut verts = Vec::new();
    let normal = [0.0_f32, 1.0, 0.0];
    let cross = 0.2_f32;
    for l in lights {
        let p = l.position;
        let color = l.color;
        // small cross marking the light position
        verts.push(Vertex { position: [p[0] - cross, p[1], p[2]], color, normal });
        verts.push(Vertex { position: [p[0] + cross, p[1], p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1] - cross, p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1] + cross, p[2]], color, normal });
        verts.push(Vertex { position: [p[0], p[1], p[2] - cross], color, normal });
        verts.push(Vertex { position: [p[0], p[1], p[2] + cross], color, normal });
        // line from light to origin
        verts.push(Vertex { position: p, color, normal });
        verts.push(Vertex { position: [0.0, 0.0, 0.0], color, normal });
    }
    verts
}


\n# File: src/render/depth.rs
#![cfg(target_arch = "wasm32")]

use wgpu::{Device, Texture, TextureFormat, TextureView};

pub fn create(device: &Device, w: u32, h: u32, format: TextureFormat) -> (Texture, TextureView) {
    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth texture"),
        size: wgpu::Extent3d {
            width: w,
            height: h,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    (texture, view)
}

\n# File: src/render/mod.rs
#![cfg(target_arch = "wasm32")]

pub mod data;
pub mod depth;
pub mod pipeline;
pub mod state;

\n# File: src/render/pipeline.rs
#![cfg(target_arch = "wasm32")]

use crate::render::data::Vertex;
use wgpu::{BindGroupLayout, Device, RenderPipeline, TextureFormat};

pub fn build(device: &Device, format: TextureFormat, layout: &BindGroupLayout) -> RenderPipeline {
    let shader = device.create_shader_module(wgpu::include_wgsl!("../shader.wgsl"));
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline layout"),
        bind_group_layouts: &[layout],
        push_constant_ranges: &[],
    });
    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: Some("vs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            buffers: &[Vertex::layout()],
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: Some("fs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            targets: &[Some(wgpu::ColorTargetState {
                format,
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            cull_mode: Some(wgpu::Face::Front),
            front_face: wgpu::FrontFace::Ccw,
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: Default::default(),
            bias: Default::default(),
        }),
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
        cache: None,
    })
}

pub fn build_lines(device: &Device, format: TextureFormat, layout: &BindGroupLayout) -> RenderPipeline {
    let shader = device.create_shader_module(wgpu::include_wgsl!("../shader.wgsl"));
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("grid pipeline layout"),
        bind_group_layouts: &[layout],
        push_constant_ranges: &[],
    });
    device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("grid pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: Some("vs_main"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            buffers: &[Vertex::layout()],
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: Some("fs_color"),
            compilation_options: wgpu::PipelineCompilationOptions::default(),
            targets: &[Some(wgpu::ColorTargetState {
                format,
                blend: Some(wgpu::BlendState::REPLACE),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::LineList,
            cull_mode: None,
            front_face: wgpu::FrontFace::Ccw,
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: false,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: Default::default(),
            bias: Default::default(),
        }),
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
        cache: None,
    })
}


\n# File: src/render/state.rs
#![cfg(target_arch = "wasm32")]

use glam::{Mat4, Vec3};
use wasm_bindgen::JsValue;
use web_sys::HtmlCanvasElement;
use wgpu::util::DeviceExt;

use crate::render::data::{self, Light as ShaderLight, SceneUniforms};
use crate::render::{depth, pipeline};
use crate::scene::{Light, Node, Scene};

pub struct State {
    grid_pipeline: wgpu::RenderPipeline,
    grid_vertex_buffer: wgpu::Buffer,
    grid_vertex_count: u32,
    light_vertex_buffer: wgpu::Buffer,
    light_vertex_count: u32,
    pub draw_grid: bool,
    pub scene: Scene,
    instance_uniform_buffer: wgpu::Buffer,
    light_uniform_buffer: wgpu::Buffer,
    surface: wgpu::Surface<'static>,
    device: wgpu::Device,
    queue: wgpu::Queue,
    config: wgpu::SurfaceConfiguration,
    pipeline: wgpu::RenderPipeline,
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    cube_uniform_buffer: wgpu::Buffer,
    grid_uniform_buffer: wgpu::Buffer,
    cube_bind_group: wgpu::BindGroup,
    grid_bind_group: wgpu::BindGroup,
    depth_texture: wgpu::Texture,
    depth_view: wgpu::TextureView,
    depth_format: wgpu::TextureFormat,
    pub aspect: f32,
    camera_matrix: Mat4,
    camera_pos: glam::Vec3,
}

impl State {
    pub async fn new(canvas: &HtmlCanvasElement) -> Result<Self, JsValue> {
        let instance = wgpu::Instance::default();
        let surface = instance
            .create_surface(wgpu::SurfaceTarget::Canvas(canvas.clone()))
            .map_err(|e| JsValue::from_str(&format!("{e:?}")))?;
        let surface =
            unsafe { std::mem::transmute::<wgpu::Surface<'_>, wgpu::Surface<'static>>(surface) };
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::HighPerformance,
                compatible_surface: Some(&surface),
                force_fallback_adapter: false,
            })
            .await
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        let (device, queue) = adapter
            .request_device(&wgpu::DeviceDescriptor {
                label: None,
                required_features: wgpu::Features::empty(),
                required_limits: adapter.limits(),
                memory_hints: wgpu::MemoryHints::default(),
                trace: wgpu::Trace::default(),
            })
            .await
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        let caps = surface.get_capabilities(&adapter);
        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: caps.formats[0],
            width: canvas.width(),
            height: canvas.height(),
            present_mode: caps.present_modes[0],
            desired_maximum_frame_latency: 2,
            alpha_mode: caps.alpha_modes[0],
            view_formats: vec![],
        };
        surface.configure(&device, &config);
        let aspect = config.width as f32 / config.height as f32;

        let depth_format = wgpu::TextureFormat::Depth32Float;
        let (depth_texture, depth_view) =
            depth::create(&device, config.width, config.height, depth_format);

        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("vertex buffer"),
            contents: data::as_bytes(data::VERTICES),
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        });
        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("index buffer"),
            contents: data::as_bytes(data::INDICES),
            usage: wgpu::BufferUsages::INDEX | wgpu::BufferUsages::COPY_DST,
        });

        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("bind group layout"),
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        });

        let pipeline = pipeline::build(&device, config.format, &bind_group_layout);
        let grid_pipeline = pipeline::build_lines(&device, config.format, &bind_group_layout);
        let grid_vertices = data::grid_vertices(10);
        let grid_vertex_count = grid_vertices.len() as u32;
        let grid_vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("grid vertex buffer"),
            contents: data::as_bytes(&grid_vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        let mut scene = Scene::new();
        scene.nodes.push(Node {
            model: Mat4::IDENTITY.to_cols_array_2d(),
            parent: -1,
            _pad: [0; 3],
        });
        scene.lights.push(Light {
            position: [1.5, 1.0, 2.0],
            _pad_p: 0.0,
            color: [1.0, 1.0, 1.0],
            _pad_c: 0.0,
        });
        scene.lights.push(Light {
            position: [-1.5, 1.0, -2.0],
            _pad_p: 0.0,
            color: [1.0, 0.0, 0.0],
            _pad_c: 0.0,
        });

        let instance_uniform_buffer =
            device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("instance buffer"),
                contents: data::as_bytes(&scene.nodes),
                usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST,
            });
        let light_uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("light buffer"),
            contents: data::as_bytes(&scene.lights),
            usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST,
        });

        let uniform = SceneUniforms {
            mvp: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0],
            ],
            model: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0],
            ],
            camera_pos: [0.0, 0.0, 0.0],
            _pad0: 0.0,
            lights: [
                ShaderLight {
                    position: [1.5, 1.0, 2.0],
                    _pad_p: 0.0,
                    color: [1.0, 1.0, 1.0],
                    _pad_c: 0.0,
                },
                ShaderLight {
                    position: [-1.5, 1.0, -2.0],
                    _pad_p: 0.0,
                    color: [1.0, 0.0, 0.0],
                    _pad_c: 0.0,
                },
            ],
        };

        let light_vertices = data::light_rays(&uniform.lights);
        let light_vertex_count = light_vertices.len() as u32;
        let light_vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("light vertex buffer"),
            contents: data::as_bytes(&light_vertices),
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        });
        let cube_uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("cube uniform buffer"),
            contents: data::as_bytes(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        let cube_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout: &bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: cube_uniform_buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: instance_uniform_buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: light_uniform_buffer.as_entire_binding(),
                },
            ],
            label: Some("bind group"),
        });
        let grid_uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("grid uniform buffer"),
            contents: data::as_bytes(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        let grid_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout: &bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: grid_uniform_buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: instance_uniform_buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: light_uniform_buffer.as_entire_binding(),
                },
            ],
            label: Some("grid bind group"),
        });

        Ok(Self {
            grid_pipeline,
            grid_vertex_buffer,
            grid_vertex_count,
            light_vertex_buffer,
            light_vertex_count,
            draw_grid: true,
            scene,
            instance_uniform_buffer,
            light_uniform_buffer,
            surface,
            device,
            queue,
            config,
            pipeline,
            vertex_buffer,
            index_buffer,
            cube_uniform_buffer,
            grid_uniform_buffer,
            cube_bind_group,
            grid_bind_group,
            depth_texture,
            depth_view,
            depth_format,
            aspect,
            camera_matrix: Mat4::IDENTITY,
            camera_pos: Vec3::ZERO,
        })
    }
    pub fn set_grid_visible(&mut self, show: bool) {
        self.draw_grid = show;
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        if width == 0 || height == 0 {
            return;
        }
        self.config.width = width;
        self.config.height = height;
        self.aspect = width as f32 / height as f32;
        self.surface.configure(&self.device, &self.config);
        let (depth_texture, depth_view) =
            depth::create(&self.device, width, height, self.depth_format);
        self.depth_texture = depth_texture;
        self.depth_view = depth_view;
    }

    pub fn update(&mut self, camera_matrix: Mat4, model: Mat4, camera_pos: Vec3) {
        self.camera_matrix = camera_matrix;
        self.camera_pos = camera_pos;
        if let Some(node) = self.scene.nodes.get_mut(0) {
            node.model = model.to_cols_array_2d();
        }
        let mut lights_arr = [ShaderLight {
            position: [0.0; 3],
            _pad_p: 0.0,
            color: [0.0; 3],
            _pad_c: 0.0,
        }; 2];
        for (i, l) in self.scene.lights.iter().take(2).enumerate() {
            lights_arr[i] = ShaderLight {
                position: l.position,
                _pad_p: l._pad_p,
                color: l.color,
                _pad_c: l._pad_c,
            };
        }
        let grid_uniform = SceneUniforms {
            mvp: camera_matrix.to_cols_array_2d(),
            model: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0],
            ],
            camera_pos: camera_pos.into(),
            _pad0: 0.0,
            lights: lights_arr,
        };
        self.queue.write_buffer(
            &self.grid_uniform_buffer,
            0,
            data::as_bytes(&[grid_uniform]),
        );
        self.queue.write_buffer(
            &self.instance_uniform_buffer,
            0,
            data::as_bytes(&self.scene.nodes),
        );
        self.queue.write_buffer(
            &self.light_uniform_buffer,
            0,
            data::as_bytes(&self.scene.lights),
        );
        let light_vertices = data::light_rays(&lights_arr);
        self.queue.write_buffer(
            &self.light_vertex_buffer,
            0,
            data::as_bytes(&light_vertices),
        );
    }

    pub fn render(&mut self) -> Result<(), wgpu::SurfaceError> {
        let frame = self.surface.get_current_texture()?;
        let view = frame
            .texture
            .create_view(&wgpu::TextureViewDescriptor::default());
        let mut encoder = self
            .device
            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                label: Some("encoder"),
            });
        {
            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("render"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color {
                            r: 0.1,
                            g: 0.1,
                            b: 0.3,
                            a: 1.0,
                        }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                    view: &self.depth_view,
                    depth_ops: Some(wgpu::Operations {
                        load: wgpu::LoadOp::Clear(1.0),
                        store: wgpu::StoreOp::Store,
                    }),
                    stencil_ops: None,
                }),
                occlusion_query_set: None,
                timestamp_writes: None,
            });
            rp.set_pipeline(&self.pipeline);
            rp.set_bind_group(0, &self.cube_bind_group, &[]);
            rp.set_vertex_buffer(0, self.vertex_buffer.slice(..));
            rp.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);

            let mut lights_arr = [ShaderLight {
                position: [0.0; 3],
                _pad_p: 0.0,
                color: [0.0; 3],
                _pad_c: 0.0,
            }; 2];
            for (i, l) in self.scene.lights.iter().take(2).enumerate() {
                lights_arr[i] = ShaderLight {
                    position: l.position,
                    _pad_p: l._pad_p,
                    color: l.color,
                    _pad_c: l._pad_c,
                };
            }

            for (i, node) in self.scene.nodes.iter().enumerate() {
                let mut model = Mat4::from_cols_array_2d(&node.model);
                let mut p = node.parent;
                while p >= 0 {
                    let parent = &self.scene.nodes[p as usize];
                    model = Mat4::from_cols_array_2d(&parent.model) * model;
                    p = parent.parent;
                }
                let mvp = self.camera_matrix * model;
                let cube_uniform = SceneUniforms {
                    mvp: mvp.to_cols_array_2d(),
                    model: model.to_cols_array_2d(),
                    camera_pos: self.camera_pos.into(),
                    _pad0: 0.0,
                    lights: lights_arr,
                };
                self.queue.write_buffer(
                    &self.cube_uniform_buffer,
                    0,
                    data::as_bytes(&[cube_uniform]),
                );
                rp.draw_indexed(0..data::INDICES.len() as u32, 0, i as u32..i as u32 + 1);
            }
            if self.draw_grid {
                rp.set_pipeline(&self.grid_pipeline);
                rp.set_bind_group(0, &self.grid_bind_group, &[]);
                rp.set_vertex_buffer(0, self.grid_vertex_buffer.slice(..));
                rp.draw(0..self.grid_vertex_count, 0..1);
                rp.set_vertex_buffer(0, self.light_vertex_buffer.slice(..));
                rp.draw(0..self.light_vertex_count, 0..1);
            }
        }
        self.queue.submit(Some(encoder.finish()));
        frame.present();
        Ok(())
    }
}

\n# File: src/scene.rs
use glam::Mat4;

#[repr(C)]
#[derive(Clone, Copy)]
pub struct Light {
    pub position: [f32; 3],
    pub _pad_p: f32,
    pub color: [f32; 3],
    pub _pad_c: f32,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct Node {
    pub model: [[f32; 4]; 4],
    pub parent: i32,    // -1 = no parent
    pub _pad: [i32; 3], // 16 B alignment
}

pub struct Scene {
    pub nodes: Vec<Node>,
    pub lights: Vec<Light>,
}

impl Scene {
    pub fn new() -> Self {
        Self {
            nodes: Vec::new(),
            lights: Vec::new(),
        }
    }
}

\n# File: src/shader.wgsl
struct Light {
    position: vec3<f32>,
    _pad_p: f32,
    color: vec3<f32>,
    _pad_c: f32,
};

struct SceneUniforms {
    mvp: mat4x4<f32>,
    model: mat4x4<f32>,
    camera_pos: vec3<f32>,
    _pad0: f32,
    lights: array<Light, 2>,
};

struct Node {
    model: mat4x4<f32>,
    parent: i32,
    _pad: vec3<i32>,
};

@group(0) @binding(0) var<uniform> scene: SceneUniforms;
@group(0) @binding(1) var<storage, read> nodes: array<Node>;
@group(0) @binding(2) var<storage, read> lights_buf: array<Light>;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) color: vec3<f32>,
    @location(2) normal: vec3<f32>,
};

struct VertexOutput {
    @builtin(position) pos: vec4<f32>,
    @location(0) color: vec3<f32>,
    @location(1) world_pos: vec3<f32>,
    @location(2) world_normal: vec3<f32>,
};

@vertex
fn vs_main(input: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.pos = scene.mvp * vec4<f32>(input.position, 1.0);
    out.color = input.color;
    out.world_pos = (scene.model * vec4<f32>(input.position, 1.0)).xyz;
    // Transform the normal by the model matrix without applying translation
    // (w = 0). This keeps lighting separate from camera rotation.
    out.world_normal = normalize((scene.model * vec4<f32>(input.normal, 0.0)).xyz);
    return out;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let normal = normalize(input.world_normal);
    let view_dir = normalize(scene.camera_pos - input.world_pos);
    var result = input.color * 0.1; // ambient

    // light 0
    let l0_dir = normalize(scene.lights[0].position - input.world_pos);
    let diff0 = max(dot(normal, l0_dir), 0.0);
    let spec0 = pow(max(dot(normal, normalize(l0_dir + view_dir)), 0.0), 32.0);
    result += (diff0 * input.color + spec0) * scene.lights[0].color;

    // light 1
    let l1_dir = normalize(scene.lights[1].position - input.world_pos);
    let diff1 = max(dot(normal, l1_dir), 0.0);
    let spec1 = pow(max(dot(normal, normalize(l1_dir + view_dir)), 0.0), 32.0);
    result += (diff1 * input.color + spec1) * scene.lights[1].color;

    return vec4<f32>(result, 1.0);
}

@fragment
fn fs_color(input: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(input.color, 1.0);
}

\n# File: src/web.rs
#![cfg(target_arch = "wasm32")]

use std::{cell::RefCell, rc::Rc};
use wasm_bindgen::prelude::*;
use wasm_bindgen::{closure::Closure, JsCast};

use crate::scene::{Light, Node};
use glam::{Mat4, Vec3};

use crate::input::active_camera::{ActiveCamera, CameraType};
use crate::input::camera::CameraController;
use crate::input::{keyboard, mouse};
use crate::render::state::State;

thread_local! {
    static STATE: RefCell<Option<Rc<RefCell<State>>>> = RefCell::new(None);
    static CAMERA: RefCell<Option<Rc<RefCell<ActiveCamera>>>> = RefCell::new(None);
    static COMMANDS: RefCell<Vec<Command>> = RefCell::new(Vec::new());
}

enum Command {
    AddNode { model: Mat4, parent: i32 },
    AddLight { pos: [f32; 3], color: [f32; 3] },
}

#[wasm_bindgen]
pub fn set_grid_visible(show: bool) {
    STATE.with(|s| {
        if let Some(st) = &*s.borrow() {
            st.borrow_mut().set_grid_visible(show);
        }
    });
}

#[wasm_bindgen]
pub fn set_camera_mode(mode: &str) {
    CAMERA.with(|c| {
        if let Some(cam) = &*c.borrow() {
            let mut cam = cam.borrow_mut();
            match mode {
                "free" => cam.set_type(CameraType::Free),
                "orbit" => cam.set_type(CameraType::Orbit),
                _ => {}
            }
        }
    });
}

#[wasm_bindgen]
pub fn add_cube(x: f32, y: f32, z: f32, parent: i32) {
    COMMANDS.with(|q| {
        q.borrow_mut().push(Command::AddNode {
            model: Mat4::from_translation(Vec3::new(x, y, z)),
            parent,
        });
    });
}

#[wasm_bindgen]
pub fn add_light(x: f32, y: f32, z: f32, r: f32, g: f32, b: f32) {
    COMMANDS.with(|q| {
        q.borrow_mut().push(Command::AddLight {
            pos: [x, y, z],
            color: [r, g, b],
        });
    });
}

#[wasm_bindgen]
pub fn resize(width: u32, height: u32) {
    STATE.with(|s| {
        if let Some(st) = &*s.borrow() {
            st.borrow_mut().resize(width, height);
        }
    });
    CAMERA.with(|c| {
        if let Some(cam) = &*c.borrow() {
            cam.borrow_mut().set_aspect(width as f32 / height as f32);
        }
    });
}

#[wasm_bindgen(start)]
pub async fn start() -> Result<(), JsValue> {
    console_error_panic_hook::set_once();
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let canvas = document
        .get_element_by_id("gpu-canvas")
        .unwrap()
        .dyn_into::<web_sys::HtmlCanvasElement>()?;

    let state = Rc::new(RefCell::new(State::new(&canvas).await?));
    STATE.with(|s| *s.borrow_mut() = Some(state.clone()));
    let performance = window.performance().unwrap();
    let aspect = state.borrow().aspect;
    let camera = Rc::new(RefCell::new(ActiveCamera::new(aspect)));
    CAMERA.with(|c| *c.borrow_mut() = Some(camera.clone()));

    keyboard::attach(&window, camera.clone());
    mouse::attach(&window, &canvas, camera.clone());

    let start_time = performance.now();
    let prev_time = Rc::new(RefCell::new(start_time));
    let f: Rc<RefCell<Option<Closure<dyn FnMut()>>>> = Rc::new(RefCell::new(None));
    let g = f.clone();
    let window_c = window.clone();
    let perf_c = performance.clone();
    let camera_c = camera.clone();
    let state_c = state.clone();
    let prev_time_c = prev_time.clone();

    *g.borrow_mut() = Some(Closure::wrap(Box::new(move || {
        let now = perf_c.now();
        let dt = (now - *prev_time_c.borrow()) as f32 / 1000.0;
        *prev_time_c.borrow_mut() = now;
        let elapsed = (now - start_time) as f32 / 1000.0;
        let angle = elapsed / 5.0 * (2.0 * std::f32::consts::PI);
        COMMANDS.with(|q| {
            let mut q = q.borrow_mut();
            if !q.is_empty() {
                let mut st = state_c.borrow_mut();
                for cmd in q.drain(..) {
                    match cmd {
                        Command::AddNode { model, parent } => {
                            st.scene.nodes.push(Node {
                                model: model.to_cols_array_2d(),
                                parent,
                                _pad: [0; 3],
                            });
                        }
                        Command::AddLight { pos, color } => {
                            st.scene.lights.push(Light {
                                position: pos,
                                _pad_p: 0.0,
                                color,
                                _pad_c: 0.0,
                            });
                        }
                    }
                }
            }
        });
        {
            let mut cam = camera_c.borrow_mut();
            cam.update(dt);
            let cam_pos = cam.position();
            let cam_matrix = cam.matrix();
            let model = Mat4::from_rotation_z(angle);
            let mut st = state_c.borrow_mut();
            st.update(cam_matrix, model, cam_pos);
            if st.render().is_err() {
                return;
            }
        }
        window_c
            .request_animation_frame(f.borrow().as_ref().unwrap().as_ref().unchecked_ref())
            .unwrap();
    }) as Box<dyn FnMut()>));

    window.request_animation_frame(g.borrow().as_ref().unwrap().as_ref().unchecked_ref())?;
    Ok(())
}

